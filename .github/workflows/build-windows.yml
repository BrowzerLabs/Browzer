name: Build and Release Windows

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to build (e.g., v1.0.0)'
        required: false
        default: ''

env:
  NODE_VERSION: '22'
  PNPM_VERSION: '10.19.0'

jobs:
  build-windows:
    runs-on: windows-latest
    
    strategy:
      matrix:
        arch: [x64, arm64]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: ${{ env.PNPM_VERSION }}
      
      - name: Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Update version in package.json
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          
          # Remove 'v' prefix if present
          VERSION_NUMBER="${VERSION#v}"
          
          echo "Updating package.json to version: $VERSION_NUMBER"
          
          # Update package.json version (Windows compatible)
          node -e "const fs=require('fs');const pkg=JSON.parse(fs.readFileSync('package.json'));pkg.version='$VERSION_NUMBER';fs.writeFileSync('package.json',JSON.stringify(pkg,null,2)+'\n');"
          
          # Verify the update
          grep "\"version\":" package.json
      
      - name: Install Azure Trusted Signing dlib
        shell: pwsh
        run: |
          Write-Host "Installing Azure Code Signing tools..."
          
          # Install Azure Trusted Signing client
          Invoke-WebRequest -Uri "https://www.nuget.org/api/v2/package/Microsoft.Trusted.Signing.Client" -OutFile "signing-client.zip"
          Expand-Archive -Path "signing-client.zip" -DestinationPath "signing-client" -Force
          
          # Find the signing tool
          $signingTool = Get-ChildItem -Path "signing-client" -Filter "SignTool.exe" -Recurse | Select-Object -First 1
          
          if ($signingTool) {
            Write-Host "Found SignTool at: $($signingTool.FullName)"
            $signingDir = $signingTool.Directory.FullName
            echo "SIGNING_TOOL_PATH=$signingDir" >> $env:GITHUB_ENV
            echo "$signingDir" >> $env:GITHUB_PATH
          } else {
            Write-Host "SignTool not found, using system SignTool"
          }
      
      - name: Setup Azure Code Signing
        shell: pwsh
        run: |
          Write-Host "Setting up Azure Trusted Signing parameters..."
          
          # Build signing parameters for Azure Trusted Signing
          $signParams = @(
            "/fd sha256",
            "/tr http://timestamp.digicert.com",
            "/td sha256",
            "/dlib `"${{ secrets.AZURE_DLIB_PATH }}`"",
            "/dmdf `"${{ secrets.AZURE_METADATA_FILE }}`""
          ) -join " "
          
          echo "WINDOWS_SIGN_PARAMS=$signParams" >> $env:GITHUB_ENV
          
          Write-Host "Signing parameters configured"
      
      - name: Create Azure Trusted Signing metadata file
        shell: pwsh
        run: |
          $metadata = @{
            "Endpoint" = "${{ secrets.AZURE_ENDPOINT }}"
            "CodeSigningAccountName" = "${{ secrets.AZURE_CODE_SIGNING_ACCOUNT_NAME }}"
            "CertificateProfileName" = "${{ secrets.AZURE_CERTIFICATE_PROFILE_NAME }}"
          } | ConvertTo-Json
          
          $metadataFile = Join-Path $env:TEMP "metadata.json"
          $metadata | Out-File -FilePath $metadataFile -Encoding utf8
          
          echo "AZURE_METADATA_FILE=$metadataFile" >> $env:GITHUB_ENV
          
          Write-Host "Metadata file created at: $metadataFile"
      
      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Build for Windows (${{ matrix.arch }})
        shell: bash
        env:
          NODE_ENV: production
          BACKEND_API_URL: ${{ secrets.BACKEND_API_URL }}
          WINDOWS_SIGN_PARAMS: ${{ env.WINDOWS_SIGN_PARAMS }}
        run: |
          echo "Building for ${{ matrix.arch }}..."
          pnpm run make -- --arch=${{ matrix.arch }} --platform=win32
      
      - name: List build output
        shell: bash
        run: |
          echo "Build output:"
          find out -type f \( -name "*.exe" -o -name "*.nupkg" -o -name "RELEASES" \)
      
      - name: Generate checksums
        shell: bash
        run: |
          echo "Generating checksums..."
          find out/make -type f -name "*.exe" | while read file; do
            echo "Processing: $file"
            sha256sum "$file" | tee "$file.sha256"
            sha512sum "$file" | tee "$file.sha512"
          done
      
      - name: Verify code signing
        shell: pwsh
        run: |
          Write-Host "Verifying code signatures..."
          Get-ChildItem -Path "out" -Filter "*.exe" -Recurse | ForEach-Object {
            Write-Host "Checking: $($_.FullName)"
            $sig = Get-AuthenticodeSignature $_.FullName
            Write-Host "Status: $($sig.Status)"
            Write-Host "Signer: $($sig.SignerCertificate.Subject)"
            if ($sig.Status -ne "Valid") {
              Write-Warning "Signature verification failed for $($_.FullName)"
            }
          }
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: browzer-windows-${{ matrix.arch }}
          path: |
            out/make/**/*.exe
            out/make/**/*.nupkg
            out/make/**/RELEASES
            out/make/**/*.sha256
            out/make/**/*.sha512
          retention-days: 30
          if-no-files-found: error
      
      - name: Cleanup
        if: always()
        shell: pwsh
        run: |
          if (Test-Path $env:AZURE_METADATA_FILE) {
            Remove-Item $env:AZURE_METADATA_FILE -Force
          }

  create-release:
    needs: build-windows
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/') || (github.event_name == 'workflow_dispatch' && github.event.inputs.version != '')
    
    permissions:
      contents: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Display structure of downloaded files
        run: ls -R artifacts
      
      - name: Prepare release files
        id: prepare
        run: |
          mkdir -p release-files
          
          # Copy all EXE, NUPKG, and RELEASES files
          find artifacts -type f \( -name "*.exe" -o -name "*.nupkg" -o -name "RELEASES" -o -name "*.sha256" -o -name "*.sha512" \) -exec cp {} release-files/ \;
          
          echo "Release files:"
          ls -lh release-files/
          
          # Get version from tag or manual input
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=${GITHUB_REF#refs/tags/}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      - name: Create latest.yml for auto-updater
        run: |
          VERSION="${{ steps.prepare.outputs.version }}"
          VERSION_NUMBER="${VERSION#v}"
          
          # Find the main installer EXE
          INSTALLER_X64=$(find release-files -name "*Setup.exe" -o -name "*-x64-*.exe" | grep -v "arm64" | head -1)
          INSTALLER_ARM64=$(find release-files -name "*-arm64-*.exe" | head -1)
          
          # Use x64 as primary installer
          if [ -n "$INSTALLER_X64" ]; then
            INSTALLER_FILE="$INSTALLER_X64"
          elif [ -n "$INSTALLER_ARM64" ]; then
            INSTALLER_FILE="$INSTALLER_ARM64"
          else
            echo "Error: No installer EXE found!"
            echo "Available files:"
            ls -la release-files/
            exit 1
          fi
          
          echo "Using installer for auto-updates: $INSTALLER_FILE"
          
          # Get file info
          FILENAME=$(basename "$INSTALLER_FILE")
          SIZE=$(stat -c%s "$INSTALLER_FILE" 2>/dev/null || stat -f%z "$INSTALLER_FILE")
          SHA512=$(sha512sum "$INSTALLER_FILE" | awk '{print $1}')
          RELEASE_DATE=$(date -u +'%Y-%m-%dT%H:%M:%S.000Z')
          
          # Create latest.yml in electron-updater format for Windows
          cat > release-files/latest.yml <<EOF
          version: ${VERSION_NUMBER}
          files:
            - url: ${FILENAME}
              sha512: ${SHA512}
              size: ${SIZE}
          path: ${FILENAME}
          sha512: ${SHA512}
          releaseDate: '${RELEASE_DATE}'
          EOF
          
          echo "Generated latest.yml:"
          cat release-files/latest.yml
      
      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ steps.prepare.outputs.version }}"
          
          cat > release_notes.md <<EOF
          # Browzer ${VERSION}
          
          ## üì¶ Downloads
          
          ### Windows
          
          Choose the appropriate version for your Windows PC:
          
          - **64-bit (x64)**: Download \`Browzer-${VERSION}-x64-Setup.exe\`
          - **ARM64**: Download \`Browzer-${VERSION}-arm64-Setup.exe\`
          
          ### ‚úÖ Installation
          
          1. Download the appropriate installer
          2. Run the installer (you may need to allow it in Windows SmartScreen)
          3. Follow the installation wizard
          4. Launch Browzer from the Start Menu or Desktop shortcut
          
          ### üîê Verification
          
          Verify the integrity of your download:
          
          \`\`\`powershell
          # PowerShell
          \$hash = Get-FileHash -Algorithm SHA256 Browzer-${VERSION}-x64-Setup.exe
          \$hash.Hash -eq (Get-Content Browzer-${VERSION}-x64-Setup.exe.sha256 -Raw).Split()[0]
          \`\`\`
          
          ### üîÑ Auto-Updates
          
          Once installed, Browzer will automatically check for and install future updates.
          
          ### üìù What's New
          
          <!-- Add your release notes here -->
          
          EOF
          
          cat release_notes.md
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.prepare.outputs.version }}
          files: release-files/*
          body_path: release_notes.md
          draft: false
          prerelease: false
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Output release info
        run: |
          echo "‚úÖ Release created successfully!"
          echo "Version: ${{ steps.prepare.outputs.version }}"
          echo "Files released:"
          ls -lh release-files/

  notify-success:
    needs: [build-windows, create-release]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
      - name: Success notification
        run: |
          echo "‚úÖ Windows build and release completed successfully!"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Version: ${{ github.event.inputs.version }}"
          else
            echo "Version: ${GITHUB_REF#refs/tags/}"
          fi

  notify-failure:
    needs: [build-windows, create-release]
    runs-on: ubuntu-latest
    if: failure()
    
    steps:
      - name: Failure notification
        run: |
          echo "‚ùå Windows build or release failed!"
          echo "Check the logs above for details."
          exit 1
