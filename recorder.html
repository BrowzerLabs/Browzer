<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline'; media-src *;">
  <title>Screen Recorder</title>
</head>
<body>
<script>
  window.startRecording = async (sourceId) => {
    try {
      if (!navigator.mediaDevices) {
        throw new Error('navigator.mediaDevices is not available');
      }
      
      if (!navigator.mediaDevices.getUserMedia) {
        throw new Error('navigator.mediaDevices.getUserMedia is not available');
      }
      
      const constraints = {
        audio: false,
        video: {
          mandatory: {
            chromeMediaSource: 'desktop',
            chromeMediaSourceId: sourceId,
            minWidth: 1280,
            maxWidth: 1920,
            minHeight: 720,
            maxHeight: 1080
          }
        }
      };
      
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      
      const options = { 
        mimeType: 'video/webm;codecs=vp9', 
        videoBitsPerSecond: 2500000 
      };
      
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/webm;codecs=vp8';
      }
      
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        options.mimeType = 'video/webm';
      }
      
      window.recorder = new MediaRecorder(stream, options);
      window.chunks = [];
      
      window.recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) {
          window.chunks.push(e.data);
        } else {
        }
      };
      
      window.recorder.onstart = () => {
        window.chunks = []; // Ensure chunks array is fresh
      };
      
      window.recorder.onerror = (e) => {
        console.error('   Error details:', e.error);
      };
      
      window.recorder.onstop = () => {
        console.log('⏹️ MediaRecorder stopped, chunks collected:', window.chunks.length);
      };
      
      window.recorder.start(1000);
      return true;
      
    } catch (error) {
      console.error('❌ Recording error:', error.message);
      console.error('   Stack:', error.stack);
      return false;
    }
  };
  
  window.stopRecording = () => {
    return new Promise((resolve) => {
      if (!window.recorder) {
        resolve(null);
        return;
      }
      
      const timeout = setTimeout(() => {
        
        if (window.chunks.length > 0) {
          processChunks();
        } else {
          resolve(null);
        }
      }, 5000); // 5 second timeout
      
      const processChunks = async () => {
        clearTimeout(timeout);
        
        if (window.chunks.length === 0) {
          resolve(null);
          return;
        }
        
        try {
          const blob = new Blob(window.chunks, { type: 'video/webm' });
          
          const buffer = await blob.arrayBuffer();
          const result = Array.from(new Uint8Array(buffer));
          
          if (window.recorder && window.recorder.stream) {
            window.recorder.stream.getTracks().forEach(t => {
              t.stop();
            });
          }
          
          resolve(result);
        } catch (error) {
          console.error('❌ Error processing chunks:', error);
          resolve(null);
        }
      };
      
      window.recorder.onstop = processChunks;
      
      window.recorder.requestData();
      
      setTimeout(() => {
        window.recorder.stop();
      }, 100);
    });
  };
</script>
</body>
</html>
